import { from, iif, of, timer, interval, throwError } from 'rxjs';
import moment from 'moment';
import ICAL from 'ical.js';
import { map, mergeMap, catchError } from 'rxjs/operators';
import { ofType } from 'redux-observable';
import uuidv1 from 'uuid';

import { getEventsSuccess, postEventSuccess, getEventsFailure } from '../../actions/events';
import {
  GET_CALDAV_EVENTS_BEGIN,
  EDIT_CALDAV_SINGLE_EVENT_BEGIN,
  EDIT_CALDAV_ALL_EVENT_BEGIN,
  EDIT_CALDAV_FUTURE_EVENT_BEGIN,
  DELETE_CALDAV_SINGLE_EVENT_BEGIN,
  DELETE_CALDAV_ALL_EVENT_BEGIN,
  DELETE_CALDAV_FUTURE_EVENT_BEGIN
} from '../../actions/providers/caldav';
import { retrieveStoreEvents } from '../../actions/db/events';

import * as Credentials from '../../utils/Credentials';
import { asyncGetAllCalDavEvents } from '../../utils/client/caldav';
import * as IcalStringBuilder from '../../utils/icalStringBuilder';
import * as PARSER from '../../utils/parser';
import getDb from '../../rxdb';
import * as Providers from '../../utils/constants';
import * as dbEventActions from '../../sequelizeDB/operations/events';
import * as dbRpActions from '../../sequelizeDB/operations/recurrencepatterns';

const dav = require('dav');

export const beginGetCaldavEventsEpics = (action$) =>
  action$.pipe(
    ofType(GET_CALDAV_EVENTS_BEGIN),
    mergeMap((action) =>
      from(
        new Promise(async (resolve, reject) => {
          if (action.payload === undefined) {
            reject(getEventsFailure('Caldav user undefined!!'));
          }

          // debugger;

          try {
            const allCalDavUserEventsPromise = action.payload.map((user) =>
              asyncGetAllCalDavEvents(user.email, user.password, user.url, user.caldavType)
            );

            const allCalDavUserEvents = await Promise.all(allCalDavUserEventsPromise);
            // const cdEvents = [];
            // objOfCdEvents.forEach((indivCdProvider) =>
            //   indivCdProvider.forEach((indivCdEvent) => cdEvents.push(indivCdEvent))
            // );
            // // console.log(objOfCdEvents);
            debugger;
            resolve(allCalDavUserEvents);
          } catch (e) {
            console.log(e);
            throw e;
          }
        })
      ).pipe(
        map((resp) => getEventsSuccess(resp, Providers.CALDAV, action.payload)),
        catchError((error) => of(error))
      )
    )
  );

export const editCalDavSingleEventEpics = (action$) =>
  action$.pipe(
    ofType(EDIT_CALDAV_SINGLE_EVENT_BEGIN),
    mergeMap((action) =>
      from(editCalDavSingle(action.payload)).pipe(map((resp) => retrieveStoreEvents(resp.user)))
    )
  );

export const editCalDavAllRecurrenceEventEpics = (action$) =>
  action$.pipe(
    ofType(EDIT_CALDAV_ALL_EVENT_BEGIN),
    mergeMap((action) =>
      from(editCalDavAllRecurrenceEvents(action.payload)).pipe(
        map((resp) => retrieveStoreEvents(resp.user))
      )
    )
  );

export const editCalDavFutureRecurrenceEventEpics = (action$) =>
  action$.pipe(
    ofType(EDIT_CALDAV_FUTURE_EVENT_BEGIN),
    mergeMap((action) =>
      from(editCalDavAllFutureRecurrenceEvents(action.payload)).pipe(
        map((resp) => retrieveStoreEvents(resp.user))
      )
    )
  );

export const deleteCalDavSingleEventEpics = (action$) =>
  action$.pipe(
    ofType(DELETE_CALDAV_SINGLE_EVENT_BEGIN),
    mergeMap((action) =>
      from(deleteCalDavSingle(action.payload)).pipe(map((resp) => retrieveStoreEvents(resp.user)))
    )
  );

export const deleteCalDavAllRecurrenceEventEpics = (action$) =>
  action$.pipe(
    ofType(DELETE_CALDAV_ALL_EVENT_BEGIN),
    mergeMap((action) =>
      from(deleteCalDavAllRecurrenceEvents(action.payload)).pipe(
        map((resp) => retrieveStoreEvents(resp.user))
      )
    )
  );

export const deleteCalDavFutureRecurrenceEventEpics = (action$) =>
  action$.pipe(
    ofType(DELETE_CALDAV_FUTURE_EVENT_BEGIN),
    mergeMap((action) =>
      from(deleteCalDavAllFutureRecurrenceEvents(action.payload)).pipe(
        map((resp) => retrieveStoreEvents(resp.user))
      )
    )
  );

const editCalDavSingle = async (payload) => {
  const debug = true;
  if (debug) {
    console.log(payload);
  }
  try {
    let iCalString;

    // #region Getting information
    // // Get database
    // const db = await getDb();
    // const query = db.events
    //   .find()
    //   .where('id')
    //   .eq(payload.id);

    // // Find the proper item on database
    // const datas = await query.exec();
    // if (datas.length !== 1) {
    //   console.error('Omg, actually a collision?');
    // }
    // const data = datas[0];
    // console.log(datas, data);

    // Get Information (Sequlize)
    const data = await dbEventActions.getOneEventById(payload.id);

    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.email,
        password: user.password
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag
    };
    // #endregion

    // #region Updating of Single event, based of Recurring or not
    if (data.isRecurring) {
      // const cdAddingIntoRpQuery = db.recurrencepatterns
      //   .find()
      //   .where('originalId')
      //   .eq(data.iCalUID);

      if (debug) {
        // const resultCheck = await cdAddingIntoRpQuery.exec();
        const resultCheck = await dbRpActions.getOneRpByOId(data.iCalUID);
        console.log(resultCheck.toJSON());
      }

      dbRpActions.addRecurrenceIdsByOid(
        data.iCalUID,
        data.start.dateTime
        // moment(data.start.dateTime).format('YYYY-MM-DDThh:mm:ss')
      );
      // await cdAddingIntoRpQuery.update({
      //   $addToSet: {
      //     recurrenceIds: moment(data.start.dateTime).format('YYYY-MM-DDThh:mm:ss')
      //   }
      // });

      // For recurring events, we want to just add it to ex dates instead
      // Due to caldav nature, deleting an etag instead of updating results in deleting of
      // entire series.
      // Updating is done by pushing the entire iCal string to the server

      // // Get recurring pattern to build new iCal string for updating
      // const recurrenceObjectQuery = db.recurrencepatterns
      //   .findOne()
      //   .where('originalId')
      //   .eq(data.iCalUID);
      // const recurrence = await recurrenceObjectQuery.exec();

      const recurrence = await dbRpActions.getOneRpByOId(data.iCalUID);
      const recurrencePattern = recurrence.toJSON();

      // Builds the iCal string
      iCalString = IcalStringBuilder.buildICALStringUpdateRecurEvent(
        recurrencePattern,
        data,
        payload
      );
      console.log(iCalString);

      // Due to how there is no master,
      // We need to ensure all events that are part of the series
      // have the same iCal string such that we do not have inconsistency.
      // Run a db query, to update them all to the new iCalString.
      // const allRecurringEvents = db.events
      //   .find()
      //   .where('originalId')
      //   .eq(data.iCalUID);
      // await allRecurringEvents.update({
      //   $set: {
      //     iCALString: iCalString
      //   }
      // });
      await dbEventActions.updateEventiCalString(data.iCalUID, iCalString);
    } else {
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleEvent(payload, data);
    }
    // #endregion

    // #region Updating Calendar, Local Side
    // However, we need to run an update on that single event,
    // to ensure that all the fields are updated
    // TO-DO, ADD MORE FIELDS HERE
    // const singleRecurringEvent = db.events
    //   .find()
    //   .where('id')
    //   .eq(payload.id);
    // await singleRecurringEvent.update({
    //   $set: {
    //     summary: payload.title
    //   }
    // });

    await dbEventActions.updateEventById(payload.id, {
      summary: payload.title
    });

    const alldata = await dbEventActions.getAllEvents();
    console.log(alldata.map((e) => e.toJSON()));
    // debugger;
    // #endregion

    // #region Updating Calendar, Server Side
    // To delete a single recurring pattern, the calendar object is different.
    // So we add the string into the object we are PUT-ing to the server
    const calendarObject = {
      url: caldavUrl,
      calendarData: iCalString
    };

    // Result will throw error, we can do a seperate check here if needed.
    const result = await dav.updateCalendarObject(calendarObject, option);
    console.log(result);
    // #endregion
  } catch (error) {
    console.log('(editCalDavSingle) Error, retrying with pending action!', error, payload.id);
  }
  payload.props.history.push('/');
  return {
    providerType: Providers.EXCHANGE,
    user: payload.user
  };
};

const editCalDavAllRecurrenceEvents = async (payload) => {
  const debug = true;
  console.log(payload);
  try {
    // #region Getting information
    // // Get database
    // const db = await getDb();
    // const query = db.events
    //   .find()
    //   .where('id')
    //   .eq(payload.id);

    // // Find the proper item on database
    // const datas = await query.exec();
    // if (datas.length !== 1) {
    //   console.error('Omg, actually a collision?');
    // }
    // const data = datas[0];
    // console.log(datas, data);

    // Get Information (Sequlize)
    const data = await dbEventActions.getOneEventById(payload.id);

    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.email,
        password: user.password
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag
    };
    // #endregion

    // #region Generation of new iCalString & DB updating
    // For recurring events, we want to just add it to ex dates instead
    // Due to caldav nature, deleting an etag instead of updating results in deleting of
    // entire series.
    // Updating is done by pushing the entire iCal string to the server

    // Get recurring pattern to build new iCal string for updating
    // const recurrenceObjectQuery = db.recurrencepatterns
    //   .findOne()
    //   .where('originalId')
    //   .eq(data.iCalUID);
    // const recurrence = await recurrenceObjectQuery.exec();
    const recurrence = await dbRpActions.getOneRpByOId(data.iCalUID);
    const recurrencePattern = recurrence.toJSON();

    // Builds the iCal string
    const iCalString = IcalStringBuilder.buildICALStringUpdateAllRecurEvent(
      recurrencePattern,
      data,
      payload
    );
    console.log(iCalString);
    // debugger;

    // Due to how there is no master,
    // We need to ensure all events that are part of the series
    // have the same iCal string such that we do not have inconsistency.
    // Run a db query, to update them all to the new iCalString.
    // const allRecurringEvents = db.events
    //   .find()
    //   .where('originalId')
    //   .eq(data.iCalUID);
    // await allRecurringEvents.update({
    //   $set: {
    //     iCALString: iCalString
    //   }
    // });
    await dbEventActions.updateEventiCalString(data.iCalUID, iCalString);

    // However, we need to run an update on all the events that are not edited
    // to ensure that all the fields are updated
    // TO-DO, ADD MORE FIELDS HERE
    // const nonEditedRecurringEvent = db.events
    //   .find()
    //   .where('originalId')
    //   .eq(payload.originalId);

    // const allSpecificRecurringEvent = await nonEditedRecurringEvent.exec();
    // console.log(allSpecificRecurringEvent);
    const allSpecificRecurringEvent = await dbEventActions.getAllEventByOriginalId(
      payload.originalId
    );

    const newData = allSpecificRecurringEvent
      .map((e) => e.toJSON())
      .filter((e) => {
        const dt = moment(e.start.dateTime);
        for (let index = 0; index < recurrencePattern.recurrenceIds.length; index += 1) {
          const element = moment(recurrencePattern.recurrenceIds[index]);
          if (element.isSame(dt)) {
            return false;
          }
        }
        return true;
      });

    // // This is bad, but as I have not moved to sequalize, ignore.
    // for (let index = 0; index < newData.length; index += 1) {
    //   // eslint-disable-next-line no-await-in-loop
    //   await db.events
    //     .findOne()
    //     .where('originalId')
    //     .eq(payload.originalId)
    //     .where('start.dateTime')
    //     .eq(newData[index].start.dateTime)
    //     .update({
    //       $set: {
    //         summary: payload.title
    //       }
    //     });
    // }

    await Promise.all(
      newData.map(
        (e) =>
          dbEventActions.updateEventByiCalUIDandStartDateTime(payload.originalId, e.start.dateTime),
        {
          summary: payload.title
        }
      )
    );
    // #endregion

    // #region Updating Calendar, Server Side
    const calendarObject = {
      url: caldavUrl,
      calendarData: iCalString
    };

    // Result will throw error, we can do a seperate check here if needed.
    const result = await dav.updateCalendarObject(calendarObject, option);
    if (debug) {
      console.log(result);
    }
    // #endregion
  } catch (error) {
    console.log(
      '(editCalDavAllRecurrenceEvents) Error, retrying with pending action!',
      error,
      payload.id
    );
  }
  payload.props.history.push('/');
  return {
    providerType: Providers.EXCHANGE,
    user: payload.user
  };
};

const editCalDavAllFutureRecurrenceEvents = async (payload) => {
  const debug = true;
  console.log(payload);

  try {
    // #region Getting information
    // // Get database
    // const db = await getDb();
    // const query = db.events
    //   .find()
    //   .where('id')
    //   .eq(payload.id);

    // // Find the proper item on database
    // const datas = await query.exec();
    // if (datas.length !== 1) {
    //   console.error('Omg, actually a collision?');
    // }
    // const data = datas[0];
    // console.log(datas, data);

    // Get Information (Sequlize)
    const data = await dbEventActions.getOneEventById(payload.id);

    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl, calendarId, iCalUID } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.email,
        password: user.password
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag
    };
    // #endregion

    // #region Recurrence Pattern updating
    // const recurPatternQuery = db.recurrencepatterns
    //   .find()
    //   .where('originalId')
    //   .eq(data.iCalUID);
    // const recurPattern = await recurPatternQuery.exec();

    const recurPattern = await dbRpActions.getOneRpByOId(data.iCalUID);
    const pattern = recurPattern.toJSON();
    if (debug) {
      console.log(recurPattern.toJSON());
    }

    const updatedId = uuidv1();
    const updatedUid = uuidv1();

    const oldRecurringPattern = {};
    const newRecurrencePattern = {};
    Object.assign(newRecurrencePattern, {
      id: updatedId,
      originalId: updatedUid,
      // // Temp take from the recurrence master first, will take from the UI in future.
      // freq: payload.options.rrule.freq,
      // interval: payload.options.rrule.interval,
      freq: pattern.freq,
      interval: pattern.interval,
      // exDates: pattern.exDates.filter((exDate) =>
      //   moment(exDate).isAfter(moment(data.start.dateTime))
      // ),
      // recurrenceIds: pattern.recurrenceIds.filter((recurrId) =>
      //   moment(recurrId).isAfter(moment(data.start.dateTime))
      // ),
      exDates: pattern.exDates
        .split(',')
        .filter((exDate) => moment(exDate).isAfter(moment(data.start.dateTime)))
        .join(','),
      recurrenceIds: pattern.recurrenceIds
        .split(',')
        .filter((recurrId) => moment(recurrId).isAfter(moment(data.start.dateTime)))
        .join(','),
      recurringTypeId: moment(data.start.dateTime).format('YYYY-MM-DDTHH:mm:ss'),
      iCalUID: updatedUid,
      byEaster: '',
      byHour: '',
      byMinute: '',
      byMonth: '',
      byMonthDay: '',
      bySecond: '',
      bySetPos: '',
      byWeekDay: '',
      byWeekNo: '',
      byYearDay: ''
    });

    if (
      (pattern.until === undefined || pattern.until === null) &&
      (pattern.numberOfRepeats === undefined || pattern.numberOfRepeats === null)
    ) {
      // No end condition for this, figure out later LOL
    } else if (pattern.until === undefined || pattern.until === null) {
      // debugger;
      // The idea here is to first update the old recurrence pattern with until
      // so that we can generate a ruleset as the freq could be a daily/weekly/monthly
      // or have some weird interval.
      // Once we have done that, we filter the exdate and recurrenceids so that the old pattern
      // does not have the extra dates as the series has shortened.
      // As the start date is the same, we set the recurringtypeId as the same.
      // In the future, I need to change the freq and interval based off the UI here.
      // We also need to ensure that the id is the same due to updating of database.
      // Originalid is the caldavUID given by the server.
      Object.assign(oldRecurringPattern, {
        id: pattern.id,
        originalId: pattern.originalId,
        // freq: payload.options.rrule.freq,
        // interval: payload.options.rrule.interval,
        freq: pattern.freq,
        interval: pattern.interval,
        // exDates: pattern.exDates.filter((exDate) =>
        //   moment(exDate).isBefore(moment(data.start.dateTime))
        // ),
        // recurrenceIds: pattern.recurrenceIds.filter((rpDate) =>
        //   moment(rpDate).isBefore(moment(data.start.dateTime))
        // ),
        exDates: pattern.exDates
          .split(',')
          .filter((exDate) => moment(exDate).isBefore(moment(data.start.dateTime)))
          .join(','),
        recurrenceIds: pattern.recurrenceIds
          .split(',')
          .filter((rpDate) => moment(rpDate).isBefore(moment(data.start.dateTime)))
          .join(','),
        recurringTypeId: pattern.recurringTypeId,
        until: moment(data.start.dateTime)
          .subtract(1, 'second')
          .format('YYYY-MM-DDTHH:mm:ssZ'),
        isCount: true
      });

      // We build the ruleset based off the temp pattern, and as we dealing with count,
      // We use the all function to get the length of the input.
      // Parsed into Json for readability and able to be manipulated. RxDocs are not mutable.
      // As we editing this event, we need the minus one.
      const ruleSet = PARSER.buildRuleSet(oldRecurringPattern, pattern.recurringTypeId);
      // Recur Dates only hold events and not exceptions.
      const recurDates = ruleSet.all().map((date) => date.toJSON());
      const seriesEndCount =
        pattern.numberOfRepeats - recurDates.length - oldRecurringPattern.recurrenceIds.length;

      Object.assign(newRecurrencePattern, {
        numberOfRepeats: seriesEndCount, // New Rp needs to repeat from that day till the next.
        isCount: true
      });

      // Delete removes the definition as we want to ensure the UI uses count.
      // It checks via undefined, which deletes makes it.
      delete oldRecurringPattern.until;

      // Reassign the values of old pattern, Safety set the exdates and recurrenceids again.
      Object.assign(oldRecurringPattern, {
        numberOfRepeats: recurDates.length + oldRecurringPattern.recurrenceIds.length, // Old RP needs to repeat till the selected event minus one.
        isCount: true,
        exDates: pattern.exDates
          .split(',')
          .filter((exDate) => moment(exDate).isBefore(moment(data.start.dateTime)))
          .join(','),
        recurrenceIds: pattern.recurrenceIds
          .split(',')
          .filter((rpDate) => moment(rpDate).isBefore(moment(data.start.dateTime)))
          .join(',')
      });

      // await recurPatternQuery.update({
      //   $set: {
      //     numberOfRepeats: recurDates.length + oldRecurringPattern.recurrenceIds.length, // Old RP needs to repeat till the selected event minus one.
      //     isCount: true,
      //     exDates: pattern.exDates.filter((exDate) =>
      //       moment(exDate).isBefore(moment(data.start.dateTime))
      //     ),
      //     recurrenceIds: pattern.recurrenceIds.filter((rpDate) =>
      //       moment(rpDate).isBefore(moment(data.start.dateTime))
      //     )
      //   }
      // });

      await dbRpActions.updateRpByOid(data.iCalUID, {
        numberOfRepeats: recurDates.length + oldRecurringPattern.recurrenceIds.length, // Old RP needs to repeat till the selected event minus one.
        isCount: true,
        exDates: pattern.exDates
          .split(',')
          .filter((exDate) => moment(exDate).isBefore(moment(data.start.dateTime)))
          .join(','),
        recurrenceIds: pattern.recurrenceIds
          .split(',')
          .filter((rpDate) => moment(rpDate).isBefore(moment(data.start.dateTime)))
          .join(',')
      });
    } else {
      // Here, we assign the end condition for our recurrence pattern.
      // We set the until, and the UI will take care of the rest.
      Object.assign(newRecurrencePattern, {
        until: pattern.until,
        isCount: false
      });

      // Minus one day, and format it, to ensure that the until is properly formatted.
      // Minus one day due to how expanding of event works for caldav.
      const updatedUntil = moment(data.start.dateTime)
        .subtract(1, 'second')
        .format('YYYY-MM-DDTHH:mm:ss');

      // Update the old pattern to the start date of the selected event.
      // Ensure that the exdate and recurrenceid does not have duplicates.
      // await recurPatternQuery.update({
      //   $set: {
      //     until: updatedUntil,
      //     isCount: false,
      //     exDates: pattern.exDates.filter((exDate) =>
      //       moment(exDate).isBefore(moment(data.start.dateTime))
      //     ),
      //     recurrenceIds: pattern.recurrenceIds.filter((rpDate) =>
      //       moment(rpDate).isBefore(moment(data.start.dateTime))
      //     )
      //   }
      // });

      await dbRpActions.updateRpByOid(data.iCalUID, {
        until: updatedUntil,
        isCount: false,
        exDates: pattern.exDates
          .split(',')
          .filter((exDate) => moment(exDate).isBefore(moment(data.start.dateTime)))
          .join(','),
        recurrenceIds: pattern.recurrenceIds
          .split(',')
          .filter((rpDate) => moment(rpDate).isBefore(moment(data.start.dateTime)))
          .join(',')
      });
    }

    // Debug, also meant for generating the new icalstring based off the recurrence pattern.
    // const updatedOldRecurPattern = await recurPatternQuery.exec();
    const updatedOldRecurPattern = await dbRpActions.getOneRpByOId(data.iCalUID);
    const updatedOldPattern = recurPattern[0].toJSON();
    console.log(updatedOldPattern);

    // Builds the old iCal string, which has edited based off the recurring pattern.
    const oldiCalString = IcalStringBuilder.buildICALStringUpdateFutureRecurMasterEvent(
      updatedOldPattern,
      data,
      payload
    );
    console.log(oldiCalString);

    // Builds the new iCal string, which has been created based off the recurring pattern.
    const newiCalString = IcalStringBuilder.buildICALStringUpdateFutureRecurCreateEvent(
      newRecurrencePattern,
      data,
      payload
    );
    console.log(newiCalString);

    console.log('New Recurrence Pattern: ', newRecurrencePattern);
    // Insert the new recurrence pattern into database, as it is new, should not have any issues.
    // await db.recurrencepatterns.upsert(newRecurrencePattern);
    await dbRpActions.insertOrUpdateRp(newRecurrencePattern);

    // Update the old recurrence pattern with the new iCalString.
    // await recurPatternQuery.update({
    //   $set: {
    //     iCALString: updatedOldPattern.iCALString
    //   }
    // });
    await dbRpActions.updateRpByOid(data.iCalUID, {
      iCALString: updatedOldPattern.iCALString
    });
    // #endregion

    // #region Updating Calendar, Server Side
    const updateCalendarObject = {
      url: caldavUrl,
      calendarData: oldiCalString
    };

    // Result will throw error, we can do a seperate check here if needed.
    const updateResult = await dav.updateCalendarObject(updateCalendarObject, option);
    console.log(updateResult);
    // #endregion

    // #region Adding Future Events, Server Side
    const calendar = new dav.Calendar();
    calendar.url = caldavUrl;

    const newETag = uuidv1();
    console.log(caldavUrl, newETag, etag);

    const addCalendarObject = {
      data: newiCalString,
      filename: `${newETag}.ics`,
      xhr: xhrObject
    };

    const addResult = await dav.createCalendarObject(calendar, addCalendarObject);
    console.log(addResult);
    // #endregion

    // #region Delete away all old previous data
    // await db.events
    //   .find()
    //   .where('iCalUID')
    //   .eq(iCalUID)
    //   .remove();
    await dbEventActions.deleteEventByOriginaliCalUID(iCalUID);
    // #endregion

    // #region Updating Calendar, Local Side
    // The idea here is using the new iCalString generated, to create the new events to parse in.
    // So we first expand events based off the updated recurrence pattern and master.
    // After that, we append it into the events db for the redux to pick up and update.
    const oldFutureResults = PARSER.parseCalendarData(oldiCalString, etag, caldavUrl, calendarId);
    const oldExpanded = await PARSER.expandRecurEvents(
      oldFutureResults.map((calEvent) => calEvent.eventData)
    );
    const oldFinalResult = [
      ...oldExpanded,
      ...oldFutureResults
        .filter((e) => e.recurData === undefined || e.recurData === null)
        .map((e) => e.eventData)
    ];
    const oldFinalResultPromises = oldFinalResult.map((newEvent) => {
      newEvent.owner = user.email;
      // return db.events.upsert(newEvent);
      return dbEventActions.insertEventsIntoDatabase(newEvent);
    });
    // #endregion

    // #region Adding Future Events, Server Side
    // Here, we are roughly doing the same as the updating the calendar itself.
    // However, the problem is the the etag is not part of the iCalString.
    // And as the server does not respond correctly, due to Pg 28 of RFC 4791,
    // We do a full sync of the items, and match the etags to the event itself.
    // We sync the caldav url also, just incase.
    const newFutureResults = PARSER.parseCalendarData(
      newiCalString,
      newETag,
      caldavUrl,
      calendarId
    );
    const newExpanded = await PARSER.expandRecurEvents(
      newFutureResults.map((calEvent) => calEvent.eventData)
    );
    const newFinalResult = [
      ...newExpanded,
      ...newFutureResults
        .filter((e) => e.recurData === undefined || e.recurData === null)
        .map((e) => e.eventData)
    ];

    // You have to do a full sync as the .ics endpoint might not be valid
    const allEvents = await asyncGetAllCalDavEvents(user.email, user.password, user.url);
    // console.log(allEvents);
    const newFinalResultPromises = newFinalResult.map((newEvent) => {
      newEvent.owner = user.email;
      // return db.events.upsert(newEvent);
      return dbEventActions.insertEventsIntoDatabase(newEvent);
    });
    const newResult = await Promise.all(newFinalResultPromises);
    const oldResult = await Promise.all(oldFinalResultPromises);
    // console.log(newResult.map((e) => e.toJSON()), oldResult.map((e) => e.toJSON()));

    // Here, we update the etag of every event we have appended into the database,
    // and we update them accordingly after that again.
    const updateEtag = newResult.map((localDbItem) => {
      const json = localDbItem.toJSON();
      json.etag = allEvents.filter((event) => event.iCalUID === json.iCalUID)[0].etag;
      json.caldavUrl = allEvents.filter((event) => event.iCalUID === json.iCalUID)[0].caldavUrl;
      // return db.events.upsert(json);
      return dbEventActions.insertEventsIntoDatabase(json);
    });

    // Ensure that all etags have been updated, before going back to the main screen.
    await Promise.all(updateEtag);
    // #endregion
  } catch (error) {
    console.log(
      '(editCalDavFutureRecurrenceEventEpics) Error, retrying with pending action!',
      error,
      payload.id
    );
  }
  payload.props.history.push('/');
  return {
    providerType: Providers.EXCHANGE,
    user: payload.user
  };
};

const deleteCalDavSingle = async (payload) => {
  debugger;
  const { data, user } = payload;
  const debug = true;

  // Try catch for HTTP errors, offline etc.
  try {
    let result;

    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.email,
        password: user.password
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag
    };

    // For recurring events, we want to just add it to ex dates instead
    // Due to caldav nature, deleting an etag instead of updating results in deleting of
    // entire series.
    // Updating is done by pushing the entire iCal string to the server
    if (data.isRecurring) {
      // Get recurring pattern to build new iCal string for updating
      // const recurrenceObjectQuery = db.recurrencepatterns
      //   .findOne()
      //   .where('originalId')
      //   .eq(data.iCalUID);
      // const recurrence = await recurrenceObjectQuery.exec();
      const recurrence = await dbRpActions.getOneRpByOId(data.iCalUID);
      const recurrenceObject = recurrence.toJSON();

      // Builds the iCal string
      const iCalString = IcalStringBuilder.buildICALStringDeleteRecurEvent(
        recurrenceObject,
        data.start.dateTime,
        data
      );
      console.log(iCalString);

      // Due to how there is no master,
      // We need to ensure all events that are part of the series
      // have the same iCal string such that we do not have inconsistency.
      // Run a db query, to update them all to the new iCalString.
      // const allRecurringEvents = db.events
      //   .find()
      //   .where('originalId')
      //   .eq(data.iCalUID);
      // await allRecurringEvents.update({
      //   $set: {
      //     iCALString: iCalString
      //   }
      // });
      await dbEventActions.updateEventiCalString(data.iCalUID, iCalString);

      // To delete a single recurring pattern, the calendar object is different.
      // So we add the string into the object we are PUT-ing to the server
      const calendarData = iCalString;
      const calendarObject = {
        url: caldavUrl,
        calendarData
      };
      // Result will throw error, we can do a seperate check here if needed.
      result = await dav.updateCalendarObject(calendarObject, option);
    } else {
      // As we are deleting a single object, non recurring event
      // It is identified by etag. So for our calendar object,
      // We just need to know the endpoint, which is the caldavUrl
      const calendarObject = {
        url: caldavUrl
      };
      // Result will throw error, we can do a seperate check here if needed.
      result = await dav.deleteCalendarObject(calendarObject, option);
    }
    console.log(result);

    // Remove it from the database for updating of UI.
    // const removedEvent = await db.events
    //   .find()
    //   .where('id')
    //   .eq(data.id)
    //   .remove();
    await dbEventActions.deleteEventById(data.id);

    return { user };
  } catch (caldavError) {
    console.log('Handle Caldav pending action here', caldavError);
  }
};

const deleteCalDavAllRecurrenceEvents = async (payload) => {
  const { data, user } = payload;
  const debug = true;

  // const deleteDocs = db.events
  //   .find()
  //   .where('originalId')
  //   .eq(data.iCalUID);

  try {
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.email,
        password: user.password
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag
    };

    // To delete the entire series, find a event with an etag, and run delete on it.
    // Do not need calendar as etag is the only identifier you need.
    const calendarObject = {
      url: caldavUrl
    };
    // Result will throw error, we can do a seperate check here if needed.
    const result = await dav.deleteCalendarObject(calendarObject, option);
    console.log(result);

    // Remove all the recurring events accordingly.
    // const removedEvent = await deleteDocs.remove();

    await dbEventActions.deleteEventByOriginalId(data.iCalUID);

    return { user };
  } catch (caldavError) {
    console.log('Handle Caldav pending action here', caldavError);
  }
};

const deleteCalDavAllFutureRecurrenceEvents = async (payload) => {
  const { data, user } = payload;
  const debug = true;

  try {
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.email,
        password: user.password
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag
    };

    // For recurring events, we want to ensure exdates is clean too.
    // Clean means no duplicate, and has the right values.
    // This ensures that if we re-expand the series, the exdates are not copied over
    // It is starting to look like CalDav is just a storage service, as there can be duplicates.
    // Due to caldav nature, we can just update the end condition accordingly.
    // As we are deleting this and future events, we just need to update the end condition.
    // Updating is done by pushing the entire iCal string to the server
    // Get recurring pattern to build new iCal string for updating
    // const recurrenceObjectQuery = db.recurrencepatterns
    //   .findOne()
    //   .where('originalId')
    //   .eq(data.iCalUID);
    // const recurrence = await recurrenceObjectQuery.exec();
    const recurrence = await dbRpActions.getOneRpByOId(data.iCalUID);
    const recurrencePattern = recurrence.toJSON();
    console.log(recurrencePattern);
    debugger;

    // Problem here is that updating the rp based on the exDates and recurringIds.
    // This means we need to remove it from the rp and build the rp based on them.
    // Note that we cannot edit the RxDoc directly, therefore, we use the JsonObject
    // We set the exDates according to if it is before the selected start time.
    // Compared using moment.
    recurrencePattern.exDates = recurrencePattern.exDates
      .split(',')
      .filter((date) => moment(date).isBefore(moment(data.start.dateTime), 'day'))
      .join(',');

    // Do the same for edited ids.
    recurrencePattern.recurrenceIds = recurrencePattern.recurrenceIds
      .split(',')
      .filter((date) => moment(date).isBefore(moment(data.start.dateTime), 'day'))
      .join(',');

    const ruleSet = PARSER.buildRuleSet(recurrencePattern, recurrencePattern.recurringTypeId);
    const recurDates = ruleSet.all().map((date) => date.toJSON());
    const recurrAfterDates = recurDates.filter((date) =>
      moment(date).isSameOrAfter(moment.unix(data.start.dateTime))
    );

    let deleteWholeSeries = false;
    // To settle the end condition
    if (recurrencePattern.numberOfRepeats > 0) {
      recurrencePattern.numberOfRepeats -= recurrAfterDates.length;
      if (recurrencePattern.numberOfRepeats <= 0) {
        deleteWholeSeries = true;
      }
    } else if (recurrencePattern.until !== '') {
      // Need to test util end date, coz date time is ical type.
      const momentSelectedDt = moment(data.start.dateTime).add(-1, 'second');
      const momentPreviousDt = moment(recurrencePattern.recurringTypeId);
      recurrencePattern.until = momentSelectedDt.format('YYYY-MM-DDThh:mm:ss');
      if (momentSelectedDt.isSame(momentPreviousDt, 'day')) {
        deleteWholeSeries = true;
      }
    } else {
      // Yet to figure out how to deal with no end date.
    }

    if (deleteWholeSeries) {
      const calendarObject = {
        url: caldavUrl
      };

      // Result will throw error, we can do a seperate check here if needed.
      const result = await dav.deleteCalendarObject(calendarObject, option);
      // console.log(result);

      // const allRecurringEvents = await db.events
      //   .find()
      //   .where('originalId')
      //   .eq(data.iCalUID)
      //   .remove();
      await dbEventActions.deleteEventByOriginalId(data.iCalUID);

      // const previousRecurringPattern = await db.recurrencepatterns
      //   .find()
      //   .where('originalId')
      //   .eq(data.iCalUID)
      //   .remove();
      await dbRpActions.deleteRpByOid(data.iCalUID);
    } else {
      // Builds the iCal string
      const iCalString = IcalStringBuilder.buildICALStringDeleteRecurEvent(
        recurrencePattern,
        data.start.dateTime,
        data
      );
      console.log(iCalString);

      // Due to how there is no master,
      // We need to ensure all events that are part of the series
      // have the same iCal string such that we do not have inconsistency.
      // Run a db query, to update them all to the new iCalString.
      // const allRecurringEvents = db.events
      //   .find()
      //   .where('originalId')
      //   .eq(data.iCalUID);
      // await allRecurringEvents.update({
      //   $set: {
      //     iCALString: iCalString
      //   }
      // });
      await dbEventActions.updateEventiCalString(data.iCalUID, iCalString);

      // await recurrenceObjectQuery.update({
      //   $set: recurrencePattern
      // });
      await dbRpActions.updateRpByOid(data.iCalUID, recurrencePattern);

      // To delete a single recurring pattern, the calendar object is different.
      // So we add the string into the object we are PUT-ing to the server
      const calendarData = iCalString;
      const calendarObject = {
        url: caldavUrl,
        calendarData
      };
      // Result will throw error, we can do a seperate check here if needed.
      const result = await dav.updateCalendarObject(calendarObject, option);
      console.log(result);

      // const allevents = await db.events.find().exec();
      const allevents = await dbEventActions.getAllEvents();
      console.log(allevents);

      const deletingEvents = await Promise.all(
        recurrAfterDates.map((date) => {
          console.log(data.iCalUID, date);
          // return db.events
          //   .findOne()
          //   .where('originalId')
          //   .eq(data.iCalUID)
          //   .where('start.dateTime')
          //   .eq(date)
          //   .remove();
          return dbEventActions.deleteEventByiCalUIDandStartDateTime(
            data.iCalUID,
            moment(date).unix()
          );
        })
      );

      console.log(deletingEvents);
    }

    return { user };
  } catch (caldavError) {
    console.log('Handle Caldav pending action here', caldavError);
  }
};
